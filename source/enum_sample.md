---
title: enum_sample
date: 2020-05-07
---
Example Python program enum_sample.py

## Modules

* import builtins as python_lib_Builtin
* import math as python_lib_Math
* import math as Math
* from builtins import str as String
* from builtins import dict as python_lib_Dict
* from builtins import set as python_lib_Set
* import functools as python_lib_FuncTools
* import inspect as python_lib_Inspect
* import sys as python_lib_Sys
* python_Boot.keywords = python_lib_Set(["and", "del", "from", "not", "while", "as", "elif", "global", "or", "with", "assert", "else", "if", "pass", "yield", "break", "except", "import", "print", "float", "class", "exec", "in", "raise", "continue", "finally", "is", "return", "def", "for", "lambda", "try", "None", "list", "True", "False"])

## Classes

* class _hx_ClassRegistry(python_lib_Dict):
* class _hx_AnonObject:
* class python_Boot:
* class Enum:
* class HxOverrides:
* class python_internal_ArrayImpl:
* class Class:
* class Color(Enum):
* class EnumSample:
* class EnumValue:
* class Reflect:
* class Std:
* class Void:
* class Float:
* class Int:
* class Bool:
* class Dynamic:
* class haxe_IMap:
* class haxe_Log:
* class haxe_ds_StringMap:
* class python_HaxeIterator:
* class python_Lib:
* class python_NativeStringTools:
* class _HxException(Exception):
* class HxString:

## Methods

* 	def __init__(self):
* 	def _register(self,cls,name):
* 	def registerAbstract(self,name):
* 		def _hx_local_0(cls):
* 	def registerEnum(self,name,constructs):
* 		def _hx_local_0(cls):
* 	def registerClass(self,name,fields = None,props = None,methods = None,statics = None,interfaces = None,superClass = None):
* 		def _hx_local_0(cls):
* 	def __init__(self,fields):
* 	def arrayJoin(x,sep):
* 	def isPyBool(o):
* 	def isPyInt(o):
* 	def isPyFloat(o):
* 	def isClass(o):
* 	def isAnonObject(o):
* 	def _add_dynamic(a,b):
* 	def toString(o):
* 	def toString1(o,s):
* 					def _hx_local_1():
* 						def _hx_local_0():
* 	def isMetaType(v,t):
* 	def fields(o):
* 	def isString(o):
* 	def isArray(o):
* 	def field(o,field):
* 					def _hx_local_1(a11):
* 					def _hx_local_2():
* 					def _hx_local_3():
* 					def _hx_local_4(a13):
* 					def _hx_local_5(x2):
* 					def _hx_local_6(a15):
* 					def _hx_local_7(d):
* 					def _hx_local_8():
* 					def _hx_local_9(a18):
* 					def _hx_local_10():
* 					def _hx_local_11(sep):
* 					def _hx_local_12(e):
* 					def _hx_local_13(f2):
* 					def _hx_local_14(a12):
* 					def _hx_local_15(x1):
* 					def _hx_local_16(e1):
* 					def _hx_local_17():
* 					def _hx_local_18(f):
* 					def _hx_local_19():
* 					def _hx_local_20():
* 					def _hx_local_21():
* 					def _hx_local_22():
* 					def _hx_local_23(a1):
* 					def _hx_local_24(a14):
* 					def _hx_local_25(f1):
* 					def _hx_local_26(a21):
* 					def _hx_local_27(a17,x8):
* 					def _hx_local_28(e2):
* 					def _hx_local_29(a19,a22):
* 	def getInstanceFields(c):
* 	def getSuperClass(c):
* 	def getClassFields(c):
* 	def unsafeFastCodeAt(s,index):
* 	def handleKeywords(name):
* 	def unhandleKeywords(name):
* 	def __init__(self,tag,index,params):
* 	def __str__(self):
* 	def _hx_empty_init(_hx_o):
* 	def iterator(x):
* 	def eq(a,b):
* 	def stringOrNull(s):
* 	def shift(x):
* 	def pop(x):
* 	def push(x,e):
* 	def join(x,sep):
* 	def filter(x,f):
* 	def map(x,f):
* 	def toUpperCase(x):
* 	def toLowerCase(x):
* 	def rshift(val,n):
* 	def modf(a,b):
* 	def arrayGet(a,i):
* 	def arraySet(a,i,v):
* 	def get_length(x):
* 	def concat(a1,a2):
* 	def copy(x):
* 	def iterator(x):
* 	def indexOf(a,x,fromIndex = None):
* 	def lastIndexOf(a,x,fromIndex = None):
* 		def _hx_local_1():
* 	def join(x,sep):
* 	def toString(x):
* 	def pop(x):
* 	def push(x,e):
* 	def unshift(x,e):
* 	def remove(x,e):
* 	def shift(x):
* 	def slice(x,pos,end = None):
* 	def sort(x,f):
* 	def splice(x,pos,len):
* 	def map(x,f):
* 	def filter(x,f):
* 	def insert(a,pos,x):
* 	def reverse(a):
* 	def _get(x,idx):
* 	def _set(x,idx,v):
* 	def unsafeGet(x,idx):
* 	def unsafeSet(x,idx,val):
* 	def __init__(self, t, i, p):
* 	def RGB(r,g,b):
* 	def main():
* 	def field(o,field):
* 	def setField(o,field,value):
* 	def string(s):
* 	def trace(v,infos = None):
* 	def __init__(self):
* 	def _hx_empty_init(_hx_o):
* 	def __init__(self,it):
* 	def next(self):
* 	def hasNext(self):
* 	def _hx_empty_init(_hx_o):
* 	def println(v):
* 	def encode(s,encoding = "utf-8",errors = "strict"):
* 	def __init__(self,val):
* 	def _hx_empty_init(_hx_o):
* 	def split(s,d):
* 	def charCodeAt(s,index):
* 	def charAt(s,index):
* 	def lastIndexOf(s,str,startIndex = None):
* 	def toUpperCase(s):
* 	def toLowerCase(s):
* 	def indexOf(s,str,startIndex = None):
* 	def toString(s):
* 	def get_length(s):
* 	def fromCharCode(code):
* 	def substring(s,startIndex,endIndex = None):
* 	def substr(s,startIndex,len = None):

## Code

Python example

    import builtins as python_lib_Builtin
    import math as python_lib_Math
    import math as Math
    from builtins import str as String
    from builtins import dict as python_lib_Dict
    from builtins import set as python_lib_Set
    import functools as python_lib_FuncTools
    import inspect as python_lib_Inspect
    import sys as python_lib_Sys
    
    
    
    
    class _hx_ClassRegistry(python_lib_Dict):
    
    	def __init__(self):
    		super().__init__()
    
    	def _register(self,cls,name):
    		cls._hx_class = cls
    		cls._hx_class_name = name
    		self[name] = cls
    
    	def registerAbstract(self,name):
    		_g = self
    		def _hx_local_0(cls):
    			_g._register(cls,name)
    			return cls
    		wrapper = _hx_local_0
    		return wrapper
    
    	def registerEnum(self,name,constructs):
    		_g = self
    		def _hx_local_0(cls):
    			_g._register(cls,name)
    			cls._hx_constructs = constructs
    			return cls
    		wrapper = _hx_local_0
    		return wrapper
    
    	def registerClass(self,name,fields = None,props = None,methods = None,statics = None,interfaces = None,superClass = None):
    		_g = self
    		if (fields is None):
    			fields = []
    		if (props is None):
    			props = []
    		if (methods is None):
    			methods = []
    		if (statics is None):
    			statics = []
    		if (interfaces is None):
    			interfaces = []
    		def _hx_local_0(cls):
    			_g._register(cls,name)
    			cls._hx_fields = fields
    			cls._hx_props = props
    			cls._hx_methods = methods
    			cls._hx_statics = statics
    			cls._hx_interfaces = interfaces
    			if (superClass is not None):
    				cls._hx_super = superClass
    			return cls
    		wrapper = _hx_local_0
    		return wrapper
    
    
    class _hx_AnonObject:
    
    	def __init__(self,fields):
    		self.__dict__ = fields
    _hx_classes = _hx_ClassRegistry()
    
    
    @_hx_classes.registerClass("python.Boot", statics=["keywords","arrayJoin","isPyBool","isPyInt","isPyFloat","isClass","isAnonObject","_add_dynamic","toString","toString1","isMetaType","fields","isString","isArray","field","getInstanceFields","getSuperClass","getClassFields","unsafeFastCodeAt","handleKeywords","prefixLength","unhandleKeywords"])
    class python_Boot:
    
    	@staticmethod
    	def arrayJoin(x,sep):
    		return sep.join([python_Boot.toString1(x1,'') for x1 in x])
    
    	@staticmethod
    	def isPyBool(o):
    		return python_lib_Builtin.isinstance(o,python_lib_Builtin.bool)
    
    	@staticmethod
    	def isPyInt(o):
    		return python_lib_Builtin.isinstance(o,python_lib_Builtin.int)
    
    	@staticmethod
    	def isPyFloat(o):
    		return python_lib_Builtin.isinstance(o,python_lib_Builtin.float)
    
    	@staticmethod
    	def isClass(o):
    		return ((o is not None) and ((HxOverrides.eq(o,String) or python_lib_Inspect.isclass(o))))
    
    	@staticmethod
    	def isAnonObject(o):
    		return python_lib_Builtin.isinstance(o,_hx_AnonObject)
    
    	@staticmethod
    	def _add_dynamic(a,b):
    		if (python_lib_Builtin.isinstance(a,String) or python_lib_Builtin.isinstance(b,String)):
    			return (python_Boot.toString1(a,"") + python_Boot.toString1(b,""))
    		return (a + b)
    
    	@staticmethod
    	def toString(o):
    		return python_Boot.toString1(o,"")
    
    	@staticmethod
    	def toString1(o,s):
    		if (o is None):
    			return "null"
    		if python_lib_Builtin.isinstance(o,python_lib_Builtin.str):
    			return o
    		if (s is None):
    			s = ""
    		if (python_lib_Builtin.len(s) >= 5):
    			return "<...>"
    		if python_lib_Builtin.isinstance(o,python_lib_Builtin.bool):
    			if o:
    				return "true"
    			else:
    				return "false"
    		if python_lib_Builtin.isinstance(o,python_lib_Builtin.int):
    			return python_lib_Builtin.str(o)
    		if python_lib_Builtin.isinstance(o,python_lib_Builtin.float):
    			try:
    				if (o == python_lib_Builtin.int(o)):
    					def _hx_local_1():
    						def _hx_local_0():
    							v = o
    							return Math.floor((v + 0.5))
    						return python_lib_Builtin.str(_hx_local_0())
    					return _hx_local_1()
    				else:
    					return python_lib_Builtin.str(o)
    			except Exception as _hx_e:
    				_hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
    				e = _hx_e1
    				return python_lib_Builtin.str(o)
    		if python_lib_Builtin.isinstance(o,python_lib_Builtin.list):
    			o1 = o
    			l = python_lib_Builtin.len(o1)
    			st = "["
    			s = (HxOverrides.stringOrNull(s) + "\t")
    			_g = 0
    			while ((_g < l)):
    				i = _g
    				_g = (_g + 1)
    				prefix = ""
    				if (i > 0):
    					prefix = ","
    				st = (HxOverrides.stringOrNull(st) + HxOverrides.stringOrNull(((HxOverrides.stringOrNull(prefix) + HxOverrides.stringOrNull(python_Boot.toString1((o1[i] if i >= 0 and i < python_lib_Builtin.len(o1) else None),s))))))
    			st = (HxOverrides.stringOrNull(st) + "]")
    			return st
    		try:
    			if python_lib_Builtin.hasattr(o,"toString"):
    				return o.toString()
    		except Exception as _hx_e:
    			_hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
    			pass
    		if (python_lib_Inspect.isfunction(o) or python_lib_Inspect.ismethod(o)):
    			return "<function>"
    		if python_lib_Builtin.hasattr(o,"__class__"):
    			if python_lib_Builtin.isinstance(o,_hx_AnonObject):
    				toStr = None
    				try:
    					fields = python_Boot.fields(o)
    					fieldsStr = None
    					_g1 = []
    					_g11 = 0
    					while ((_g11 < python_lib_Builtin.len(fields))):
    						f = (fields[_g11] if _g11 >= 0 and _g11 < python_lib_Builtin.len(fields) else None)
    						_g11 = (_g11 + 1)
    						x = ((("" + HxOverrides.stringOrNull(f)) + " : ") + HxOverrides.stringOrNull(python_Boot.toString1(python_Boot.field(o,f),(HxOverrides.stringOrNull(s) + "\t"))))
    						_g1.append(x)
    						python_lib_Builtin.len(_g1)
    					fieldsStr = _g1
    					toStr = (("{ " + HxOverrides.stringOrNull(", ".join([python_Boot.toString1(x1,'') for x1 in fieldsStr]))) + " }")
    				except Exception as _hx_e:
    					_hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
    					e2 = _hx_e1
    					return "{ ... }"
    				if (toStr is None):
    					return "{ ... }"
    				else:
    					return toStr
    			if python_lib_Builtin.isinstance(o,Enum):
    				o2 = o
    				l1 = python_lib_Builtin.len(o2.params)
    				hasParams = (l1 > 0)
    				if hasParams:
    					paramsStr = ""
    					_g2 = 0
    					while ((_g2 < l1)):
    						i1 = _g2
    						_g2 = (_g2 + 1)
    						prefix1 = ""
    						if (i1 > 0):
    							prefix1 = ","
    						paramsStr = (HxOverrides.stringOrNull(paramsStr) + HxOverrides.stringOrNull(((HxOverrides.stringOrNull(prefix1) + HxOverrides.stringOrNull(python_Boot.toString1((o2.params[i1] if i1 >= 0 and i1 < python_lib_Builtin.len(o2.params) else None),s))))))
    					return (((HxOverrides.stringOrNull(o2.tag) + "(") + HxOverrides.stringOrNull(paramsStr)) + ")")
    				else:
    					return o2.tag
    			if python_lib_Builtin.hasattr(o,"_hx_class_name"):
    				if (o.__class__.__name__ != "type"):
    					fields1 = python_Boot.getInstanceFields(o)
    					fieldsStr1 = None
    					_g3 = []
    					_g12 = 0
    					while ((_g12 < python_lib_Builtin.len(fields1))):
    						f1 = (fields1[_g12] if _g12 >= 0 and _g12 < python_lib_Builtin.len(fields1) else None)
    						_g12 = (_g12 + 1)
    						x1 = ((("" + HxOverrides.stringOrNull(f1)) + " : ") + HxOverrides.stringOrNull(python_Boot.toString1(python_Boot.field(o,f1),(HxOverrides.stringOrNull(s) + "\t"))))
    						_g3.append(x1)
    						python_lib_Builtin.len(_g3)
    					fieldsStr1 = _g3
    					toStr1 = (((Std.string(o._hx_class_name) + "( ") + HxOverrides.stringOrNull(", ".join([python_Boot.toString1(x1,'') for x1 in fieldsStr1]))) + " )")
    					return toStr1
    				else:
    					fields2 = python_Boot.getClassFields(o)
    					fieldsStr2 = None
    					_g4 = []
    					_g13 = 0
    					while ((_g13 < python_lib_Builtin.len(fields2))):
    						f2 = (fields2[_g13] if _g13 >= 0 and _g13 < python_lib_Builtin.len(fields2) else None)
    						_g13 = (_g13 + 1)
    						x2 = ((("" + HxOverrides.stringOrNull(f2)) + " : ") + HxOverrides.stringOrNull(python_Boot.toString1(python_Boot.field(o,f2),(HxOverrides.stringOrNull(s) + "\t"))))
    						_g4.append(x2)
    						python_lib_Builtin.len(_g4)
    					fieldsStr2 = _g4
    					toStr2 = (((("#" + Std.string(o._hx_class_name)) + "( ") + HxOverrides.stringOrNull(", ".join([python_Boot.toString1(x1,'') for x1 in fieldsStr2]))) + " )")
    					return toStr2
    			if (o == String):
    				return "#String"
    			if (o == list):
    				return "#Array"
    			if python_lib_Builtin.callable(o):
    				return "function"
    			try:
    				if python_lib_Builtin.hasattr(o,"__repr__"):
    					return o.__repr__()
    			except Exception as _hx_e:
    				_hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
    				pass
    			if python_lib_Builtin.hasattr(o,"__str__"):
    				return o.__str__([])
    			if python_lib_Builtin.hasattr(o,"__name__"):
    				return o.__name__
    			return "???"
    		else:
    			return python_lib_Builtin.str(o)
    
    	@staticmethod
    	def isMetaType(v,t):
    		return (v == t)
    
    	@staticmethod
    	def fields(o):
    		a = []
    		if (o is not None):
    			if python_lib_Builtin.hasattr(o,"_hx_fields"):
    				fields = o._hx_fields
    				return python_lib_Builtin.list(fields)
    			if python_lib_Builtin.isinstance(o,_hx_AnonObject):
    				d = o.__dict__
    				keys = d.keys()
    				handler = python_Boot.unhandleKeywords
    				for k in keys:
    					a.append(handler(k))
    			elif python_lib_Builtin.hasattr(o,"__dict__"):
    				a1 = []
    				d1 = o.__dict__
    				keys1 = d1.keys()
    				for k in keys1:
    					a.append(k)
    		return a
    
    	@staticmethod
    	def isString(o):
    		return python_lib_Builtin.isinstance(o,python_lib_Builtin.str)
    
    	@staticmethod
    	def isArray(o):
    		return python_lib_Builtin.isinstance(o,python_lib_Builtin.list)
    
    	@staticmethod
    	def field(o,field):
    		if (field is None):
    			return None
    		_hx_local_0 = python_lib_Builtin.len((field))
    		if (_hx_local_0 == 10):
    			if ((field) == "charCodeAt"):
    				if python_lib_Builtin.isinstance(o,python_lib_Builtin.str):
    					s4 = o
    					def _hx_local_1(a11):
    						return HxString.charCodeAt(s4,a11)
    					return _hx_local_1
    		elif (_hx_local_0 == 11):
    			if ((field) == "toLowerCase"):
    				if python_lib_Builtin.isinstance(o,python_lib_Builtin.str):
    					s1 = o
    					def _hx_local_2():
    						return HxString.toLowerCase(s1)
    					return _hx_local_2
    			elif ((field) == "toUpperCase"):
    				if python_lib_Builtin.isinstance(o,python_lib_Builtin.str):
    					s2 = o
    					def _hx_local_3():
    						return HxString.toUpperCase(s2)
    					return _hx_local_3
    			elif ((field) == "lastIndexOf"):
    				if python_lib_Builtin.isinstance(o,python_lib_Builtin.str):
    					s6 = o
    					def _hx_local_4(a13):
    						return HxString.lastIndexOf(s6,a13)
    					return _hx_local_4
    				elif python_lib_Builtin.isinstance(o,python_lib_Builtin.list):
    					a2 = o
    					def _hx_local_5(x2):
    						return python_internal_ArrayImpl.lastIndexOf(a2,x2)
    					return _hx_local_5
    		elif (_hx_local_0 == 9):
    			if ((field) == "substring"):
    				if python_lib_Builtin.isinstance(o,python_lib_Builtin.str):
    					s9 = o
    					def _hx_local_6(a15):
    						return HxString.substring(s9,a15)
    					return _hx_local_6
    		elif (_hx_local_0 == 5):
    			if ((field) == "split"):
    				if python_lib_Builtin.isinstance(o,python_lib_Builtin.str):
    					s7 = o
    					def _hx_local_7(d):
    						return HxString.split(s7,d)
    					return _hx_local_7
    			elif ((field) == "shift"):
    				if python_lib_Builtin.isinstance(o,python_lib_Builtin.list):
    					x14 = o
    					def _hx_local_8():
    						return python_internal_ArrayImpl.shift(x14)
    					return _hx_local_8
    			elif ((field) == "slice"):
    				if python_lib_Builtin.isinstance(o,python_lib_Builtin.list):
    					x15 = o
    					def _hx_local_9(a18):
    						return python_internal_ArrayImpl.slice(x15,a18)
    					return _hx_local_9
    		elif (_hx_local_0 == 4):
    			if ((field) == "copy"):
    				if python_lib_Builtin.isinstance(o,python_lib_Builtin.list):
    					def _hx_local_10():
    						x6 = o
    						return python_lib_Builtin.list(x6)
    					return _hx_local_10
    			elif ((field) == "join"):
    				if python_lib_Builtin.isinstance(o,python_lib_Builtin.list):
    					def _hx_local_11(sep):
    						x9 = o
    						return sep.join([python_Boot.toString1(x1,'') for x1 in x9])
    					return _hx_local_11
    			elif ((field) == "push"):
    				if python_lib_Builtin.isinstance(o,python_lib_Builtin.list):
    					x11 = o
    					def _hx_local_12(e):
    						return python_internal_ArrayImpl.push(x11,e)
    					return _hx_local_12
    			elif ((field) == "sort"):
    				if python_lib_Builtin.isinstance(o,python_lib_Builtin.list):
    					x16 = o
    					def _hx_local_13(f2):
    						python_internal_ArrayImpl.sort(x16,f2)
    					return _hx_local_13
    		elif (_hx_local_0 == 7):
    			if ((field) == "indexOf"):
    				if python_lib_Builtin.isinstance(o,python_lib_Builtin.str):
    					s5 = o
    					def _hx_local_14(a12):
    						return HxString.indexOf(s5,a12)
    					return _hx_local_14
    				elif python_lib_Builtin.isinstance(o,python_lib_Builtin.list):
    					a = o
    					def _hx_local_15(x1):
    						return python_internal_ArrayImpl.indexOf(a,x1)
    					return _hx_local_15
    			elif ((field) == "unshift"):
    				if python_lib_Builtin.isinstance(o,python_lib_Builtin.list):
    					x12 = o
    					def _hx_local_16(e1):
    						python_internal_ArrayImpl.unshift(x12,e1)
    					return _hx_local_16
    			elif ((field) == "reverse"):
    				if python_lib_Builtin.isinstance(o,python_lib_Builtin.list):
    					a4 = o
    					def _hx_local_17():
    						python_internal_ArrayImpl.reverse(a4)
    					return _hx_local_17
    		elif (_hx_local_0 == 3):
    			if ((field) == "map"):
    				if python_lib_Builtin.isinstance(o,python_lib_Builtin.list):
    					x4 = o
    					def _hx_local_18(f):
    						return python_internal_ArrayImpl.map(x4,f)
    					return _hx_local_18
    			elif ((field) == "pop"):
    				if python_lib_Builtin.isinstance(o,python_lib_Builtin.list):
    					x10 = o
    					def _hx_local_19():
    						return python_internal_ArrayImpl.pop(x10)
    					return _hx_local_19
    		elif (_hx_local_0 == 8):
    			if ((field) == "toString"):
    				if python_lib_Builtin.isinstance(o,python_lib_Builtin.str):
    					s10 = o
    					def _hx_local_20():
    						return HxString.toString(s10)
    					return _hx_local_20
    				elif python_lib_Builtin.isinstance(o,python_lib_Builtin.list):
    					x3 = o
    					def _hx_local_21():
    						return python_internal_ArrayImpl.toString(x3)
    					return _hx_local_21
    			elif ((field) == "iterator"):
    				if python_lib_Builtin.isinstance(o,python_lib_Builtin.list):
    					x7 = o
    					def _hx_local_22():
    						return python_internal_ArrayImpl.iterator(x7)
    					return _hx_local_22
    		elif (_hx_local_0 == 6):
    			if ((field) == "length"):
    				if python_lib_Builtin.isinstance(o,python_lib_Builtin.str):
    					s = o
    					return python_lib_Builtin.len(s)
    				elif python_lib_Builtin.isinstance(o,python_lib_Builtin.list):
    					x = o
    					return python_lib_Builtin.len(x)
    			elif ((field) == "charAt"):
    				if python_lib_Builtin.isinstance(o,python_lib_Builtin.str):
    					s3 = o
    					def _hx_local_23(a1):
    						return HxString.charAt(s3,a1)
    					return _hx_local_23
    			elif ((field) == "substr"):
    				if python_lib_Builtin.isinstance(o,python_lib_Builtin.str):
    					s8 = o
    					def _hx_local_24(a14):
    						return HxString.substr(s8,a14)
    					return _hx_local_24
    			elif ((field) == "filter"):
    				if python_lib_Builtin.isinstance(o,python_lib_Builtin.list):
    					x5 = o
    					def _hx_local_25(f1):
    						return python_internal_ArrayImpl.filter(x5,f1)
    					return _hx_local_25
    			elif ((field) == "concat"):
    				if python_lib_Builtin.isinstance(o,python_lib_Builtin.list):
    					a16 = o
    					def _hx_local_26(a21):
    						return python_internal_ArrayImpl.concat(a16,a21)
    					return _hx_local_26
    			elif ((field) == "insert"):
    				if python_lib_Builtin.isinstance(o,python_lib_Builtin.list):
    					a3 = o
    					def _hx_local_27(a17,x8):
    						python_internal_ArrayImpl.insert(a3,a17,x8)
    					return _hx_local_27
    			elif ((field) == "remove"):
    				if python_lib_Builtin.isinstance(o,python_lib_Builtin.list):
    					x13 = o
    					def _hx_local_28(e2):
    						return python_internal_ArrayImpl.remove(x13,e2)
    					return _hx_local_28
    			elif ((field) == "splice"):
    				if python_lib_Builtin.isinstance(o,python_lib_Builtin.list):
    					x17 = o
    					def _hx_local_29(a19,a22):
    						return python_internal_ArrayImpl.splice(x17,a19,a22)
    					return _hx_local_29
    		else:
    			pass
    		field1 = None
    		if field in python_Boot.keywords:
    			field1 = ("_hx_" + field)
    		elif ((((python_lib_Builtin.len(field) > 2) and ((python_lib_Builtin.ord(field[0]) == 95))) and ((python_lib_Builtin.ord(field[1]) == 95))) and ((python_lib_Builtin.ord(field[(python_lib_Builtin.len(field) - 1)]) != 95))):
    			field1 = ("_hx_" + field)
    		else:
    			field1 = field
    		if python_lib_Builtin.hasattr(o,field1):
    			return python_lib_Builtin.getattr(o,field1)
    		else:
    			return None
    
    	@staticmethod
    	def getInstanceFields(c):
    		f = None
    		if python_lib_Builtin.hasattr(c,"_hx_fields"):
    			x = c._hx_fields
    			x2 = c._hx_methods
    			f = (x + x2)
    		else:
    			f = []
    		sc = python_Boot.getSuperClass(c)
    		if (sc is None):
    			return f
    		else:
    			scArr = python_Boot.getInstanceFields(sc)
    			scMap = None
    			_g = haxe_ds_StringMap()
    			_g1 = 0
    			while ((_g1 < python_lib_Builtin.len(scArr))):
    				f1 = (scArr[_g1] if _g1 >= 0 and _g1 < python_lib_Builtin.len(scArr) else None)
    				_g1 = (_g1 + 1)
    				_g.h[f1] = f1
    			scMap = _g
    			res = []
    			_g11 = 0
    			while ((_g11 < python_lib_Builtin.len(f))):
    				f11 = (f[_g11] if _g11 >= 0 and _g11 < python_lib_Builtin.len(f) else None)
    				_g11 = (_g11 + 1)
    				if (not f11 in scMap.h):
    					scArr.append(f11)
    					python_lib_Builtin.len(scArr)
    			return scArr
    
    	@staticmethod
    	def getSuperClass(c):
    		if (c is None):
    			return None
    		try:
    			if python_lib_Builtin.hasattr(c,"_hx_super"):
    				return c._hx_super
    			return None
    		except Exception as _hx_e:
    			_hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
    			pass
    		return None
    
    	@staticmethod
    	def getClassFields(c):
    		if python_lib_Builtin.hasattr(c,"_hx_statics"):
    			x = c._hx_statics
    			return python_lib_Builtin.list(x)
    		else:
    			return []
    
    	@staticmethod
    	def unsafeFastCodeAt(s,index):
    		return python_lib_Builtin.ord(s[index])
    
    	@staticmethod
    	def handleKeywords(name):
    		if name in python_Boot.keywords:
    			return ("_hx_" + name)
    		elif ((((python_lib_Builtin.len(name) > 2) and ((python_lib_Builtin.ord(name[0]) == 95))) and ((python_lib_Builtin.ord(name[1]) == 95))) and ((python_lib_Builtin.ord(name[(python_lib_Builtin.len(name) - 1)]) != 95))):
    			return ("_hx_" + name)
    		else:
    			return name
    
    	@staticmethod
    	def unhandleKeywords(name):
    		if (HxString.substr(name,0,python_Boot.prefixLength) == "_hx_"):
    			real = HxString.substr(name,python_Boot.prefixLength,None)
    			if real in python_Boot.keywords:
    				return real
    		return name
    
    
    @_hx_classes.registerClass("Enum", fields=["tag","index","params"], methods=["__str__"])
    class Enum:
    
    	def __init__(self,tag,index,params):
    		self.tag = None
    		self.index = None
    		self.params = None
    		self.tag = tag
    		self.index = index
    		self.params = params
    
    	def __str__(self):
    		if (self.params is None):
    			return self.tag
    		else:
    			return (((HxOverrides.stringOrNull(self.tag) + "(") + HxOverrides.stringOrNull(",".join([python_Boot.toString1(x1,'') for x1 in self.params]))) + ")")
    
    	@staticmethod
    	def _hx_empty_init(_hx_o):
    		_hx_o.tag = None
    		_hx_o.index = None
    		_hx_o.params = None
    
    
    @_hx_classes.registerClass("HxOverrides", statics=["iterator","eq","stringOrNull","shift","pop","push","join","filter","map","toUpperCase","toLowerCase","rshift","modf","arrayGet","arraySet"])
    class HxOverrides:
    
    	@staticmethod
    	def iterator(x):
    		if python_lib_Builtin.isinstance(x,python_lib_Builtin.list):
    			return python_HaxeIterator(x.__iter__())
    		return x.iterator()
    
    	@staticmethod
    	def eq(a,b):
    		if (python_lib_Builtin.isinstance(a,python_lib_Builtin.list) or python_lib_Builtin.isinstance(b,python_lib_Builtin.list)):
    			return a is b
    		return (a == b)
    
    	@staticmethod
    	def stringOrNull(s):
    		if (s is None):
    			return "null"
    		else:
    			return s
    
    	@staticmethod
    	def shift(x):
    		if python_lib_Builtin.isinstance(x,python_lib_Builtin.list):
    			_this = x
    			if (python_lib_Builtin.len(_this) == 0):
    				return None
    			else:
    				return _this.pop(0)
    		return x.shift()
    
    	@staticmethod
    	def pop(x):
    		if python_lib_Builtin.isinstance(x,python_lib_Builtin.list):
    			_this = x
    			if (python_lib_Builtin.len(_this) == 0):
    				return None
    			else:
    				return _this.pop()
    		return x.pop()
    
    	@staticmethod
    	def push(x,e):
    		if python_lib_Builtin.isinstance(x,python_lib_Builtin.list):
    			_this = x
    			_this.append(e)
    			return python_lib_Builtin.len(_this)
    		return x.push(e)
    
    	@staticmethod
    	def join(x,sep):
    		if python_lib_Builtin.isinstance(x,python_lib_Builtin.list):
    			return sep.join([python_Boot.toString1(x1,'') for x1 in x])
    		return x.join(sep)
    
    	@staticmethod
    	def filter(x,f):
    		if python_lib_Builtin.isinstance(x,python_lib_Builtin.list):
    			return python_lib_Builtin.list(python_lib_Builtin.filter(f,x))
    		return x.filter(f)
    
    	@staticmethod
    	def map(x,f):
    		if python_lib_Builtin.isinstance(x,python_lib_Builtin.list):
    			return python_lib_Builtin.list(python_lib_Builtin.map(f,x))
    		return x.map(f)
    
    	@staticmethod
    	def toUpperCase(x):
    		if python_lib_Builtin.isinstance(x,python_lib_Builtin.str):
    			return x.upper()
    		return x.toUpperCase()
    
    	@staticmethod
    	def toLowerCase(x):
    		if python_lib_Builtin.isinstance(x,python_lib_Builtin.str):
    			return x.lower()
    		return x.toLowerCase()
    
    	@staticmethod
    	def rshift(val,n):
    		return ((val % 0x100000000) >> n)
    
    	@staticmethod
    	def modf(a,b):
    		return float('nan') if (b == 0.0) else a % b if a > 0 else -(-a % b)
    
    	@staticmethod
    	def arrayGet(a,i):
    		if python_lib_Builtin.isinstance(a,python_lib_Builtin.list):
    			x = a
    			if ((i > -1) and ((i < python_lib_Builtin.len(x)))):
    				return x[i]
    			else:
    				return None
    		else:
    			return a[i]
    
    	@staticmethod
    	def arraySet(a,i,v):
    		if python_lib_Builtin.isinstance(a,python_lib_Builtin.list):
    			x = a
    			v1 = v
    			l = python_lib_Builtin.len(x)
    			while ((l < i)):
    				x.append(None)
    				python_lib_Builtin.len(x)
    				l = (l + 1)
    			if (l == i):
    				x.append(v1)
    				python_lib_Builtin.len(x)
    			else:
    				x[i] = v1
    			return v1
    		else:
    			a[i] = v
    			return v
    
    
    @_hx_classes.registerClass("python.internal.ArrayImpl", statics=["get_length","concat","copy","iterator","indexOf","lastIndexOf","join","toString","pop","push","unshift","remove","shift","slice","sort","splice","map","filter","insert","reverse","_get","_set","unsafeGet","unsafeSet"])
    class python_internal_ArrayImpl:
    
    	@staticmethod
    	def get_length(x):
    		return python_lib_Builtin.len(x)
    
    	@staticmethod
    	def concat(a1,a2):
    		return (a1 + a2)
    
    	@staticmethod
    	def copy(x):
    		return python_lib_Builtin.list(x)
    
    	@staticmethod
    	def iterator(x):
    		return python_HaxeIterator(x.__iter__())
    
    	@staticmethod
    	def indexOf(a,x,fromIndex = None):
    		len = python_lib_Builtin.len(a)
    		l = None
    		if (fromIndex is None):
    			l = 0
    		elif (fromIndex < 0):
    			l = (len + fromIndex)
    		else:
    			l = fromIndex
    		if (l < 0):
    			l = 0
    		_g = l
    		while ((_g < len)):
    			i = _g
    			_g = (_g + 1)
    			if (a[i] == x):
    				return i
    		return -1
    
    	@staticmethod
    	def lastIndexOf(a,x,fromIndex = None):
    		len = python_lib_Builtin.len(a)
    		l = None
    		if (fromIndex is None):
    			l = len
    		elif (fromIndex < 0):
    			l = ((len + fromIndex) + 1)
    		else:
    			l = (fromIndex + 1)
    		if (l > len):
    			l = len
    		def _hx_local_1():
    			nonlocal l
    			l = (l - 1)
    			return l
    		while ((_hx_local_1() > -1)):
    			if (a[l] == x):
    				return l
    		return -1
    
    	@staticmethod
    	def join(x,sep):
    		return sep.join([python_Boot.toString1(x1,'') for x1 in x])
    
    	@staticmethod
    	def toString(x):
    		return (("[" + HxOverrides.stringOrNull(",".join([python_Boot.toString1(x1,'') for x1 in x]))) + "]")
    
    	@staticmethod
    	def pop(x):
    		if (python_lib_Builtin.len(x) == 0):
    			return None
    		else:
    			return x.pop()
    
    	@staticmethod
    	def push(x,e):
    		x.append(e)
    		return python_lib_Builtin.len(x)
    
    	@staticmethod
    	def unshift(x,e):
    		x.insert(0, e)
    
    	@staticmethod
    	def remove(x,e):
    		try:
    			x.remove(e)
    			return True
    		except Exception as _hx_e:
    			_hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
    			e1 = _hx_e1
    			return False
    
    	@staticmethod
    	def shift(x):
    		if (python_lib_Builtin.len(x) == 0):
    			return None
    		return x.pop(0)
    
    	@staticmethod
    	def slice(x,pos,end = None):
    		return x[pos:end]
    
    	@staticmethod
    	def sort(x,f):
    		x.sort(key= python_lib_FuncTools.cmp_to_key(f))
    
    	@staticmethod
    	def splice(x,pos,len):
    		if (pos < 0):
    			pos = (python_lib_Builtin.len(x) + pos)
    		if (pos < 0):
    			pos = 0
    		res = x[pos:(pos + len)]
    		del x[pos:(pos + len)]
    		return res
    
    	@staticmethod
    	def map(x,f):
    		return python_lib_Builtin.list(python_lib_Builtin.map(f,x))
    
    	@staticmethod
    	def filter(x,f):
    		return python_lib_Builtin.list(python_lib_Builtin.filter(f,x))
    
    	@staticmethod
    	def insert(a,pos,x):
    		a.insert(pos, x)
    
    	@staticmethod
    	def reverse(a):
    		a.reverse()
    
    	@staticmethod
    	def _get(x,idx):
    		if ((idx > -1) and ((idx < python_lib_Builtin.len(x)))):
    			return x[idx]
    		else:
    			return None
    
    	@staticmethod
    	def _set(x,idx,v):
    		l = python_lib_Builtin.len(x)
    		while ((l < idx)):
    			x.append(None)
    			python_lib_Builtin.len(x)
    			l = (l + 1)
    		if (l == idx):
    			x.append(v)
    			python_lib_Builtin.len(x)
    		else:
    			x[idx] = v
    		return v
    
    	@staticmethod
    	def unsafeGet(x,idx):
    		return x[idx]
    
    	@staticmethod
    	def unsafeSet(x,idx,val):
    		x[idx] = val
    		return val
    
    
    @_hx_classes.registerAbstract("Class")
    class Class:
    	pass
    
    @_hx_classes.registerEnum("Color", ["Red","Green","Blue","RGB"])
    class Color(Enum):
    	def __init__(self, t, i, p):
    		super(Color,self).__init__(t, i, p)
    
    	@staticmethod
    	def RGB(r,g,b):
    		return Color("RGB", 3, [r,g,b])
    Color.Red = Color("Red", 0, list())
    Color.Green = Color("Green", 1, list())
    Color.Blue = Color("Blue", 2, list())
    
    
    @_hx_classes.registerClass("EnumSample", statics=["main"])
    class EnumSample:
    
    	@staticmethod
    	def main():
    		_g = Color.Blue
    		if ((_g.index) == 0):
    			haxe_Log.trace("赤",_hx_AnonObject({'fileName': "EnumSample.hx", 'lineNumber': 14, 'className': "EnumSample", 'methodName': "main"}))
    		elif ((_g.index) == 1):
    			haxe_Log.trace("緑",_hx_AnonObject({'fileName': "EnumSample.hx", 'lineNumber': 16, 'className': "EnumSample", 'methodName': "main"}))
    		elif ((_g.index) == 2):
    			haxe_Log.trace("青",_hx_AnonObject({'fileName': "EnumSample.hx", 'lineNumber': 18, 'className': "EnumSample", 'methodName': "main"}))
    		elif ((_g.index) == 3):
    			b = _g.params[2]
    			g = _g.params[1]
    			r = _g.params[0]
    			haxe_Log.trace("rgb",_hx_AnonObject({'fileName': "EnumSample.hx", 'lineNumber': 20, 'className': "EnumSample", 'methodName': "main"}))
    		else:
    			pass
    
    
    @_hx_classes.registerAbstract("EnumValue")
    class EnumValue:
    	pass
    
    
    @_hx_classes.registerClass("Reflect", statics=["field","setField"])
    class Reflect:
    
    	@staticmethod
    	def field(o,field):
    		return python_Boot.field(o,field)
    
    	@staticmethod
    	def setField(o,field,value):
    		python_lib_Builtin.setattr(o,(("_hx_" + field) if (field in python_Boot.keywords) else (("_hx_" + field) if (((((python_lib_Builtin.len(field) > 2) and ((python_lib_Builtin.ord(field[0]) == 95))) and ((python_lib_Builtin.ord(field[1]) == 95))) and ((python_lib_Builtin.ord(field[(python_lib_Builtin.len(field) - 1)]) != 95)))) else field)),value)
    
    
    @_hx_classes.registerClass("Std", statics=["string"])
    class Std:
    
    	@staticmethod
    	def string(s):
    		return python_Boot.toString1(s,"")
    
    
    @_hx_classes.registerAbstract("Void")
    class Void:
    	pass
    
    
    @_hx_classes.registerAbstract("Float")
    class Float:
    	pass
    
    
    @_hx_classes.registerAbstract("Int")
    class Int:
    	pass
    
    
    @_hx_classes.registerAbstract("Bool")
    class Bool:
    	pass
    
    
    @_hx_classes.registerAbstract("Dynamic")
    class Dynamic:
    	pass
    
    
    @_hx_classes.registerClass("haxe.IMap")
    class haxe_IMap:
    	pass
    
    
    @_hx_classes.registerClass("haxe.Log", statics=["trace"])
    class haxe_Log:
    
    	@staticmethod
    	def trace(v,infos = None):
    		str = None
    		if (infos is not None):
    			str = ((((HxOverrides.stringOrNull(infos.fileName) + ":") + Std.string(infos.lineNumber)) + ": ") + Std.string(v))
    			if (Reflect.field(infos,"customParams") is not None):
    				str = (HxOverrides.stringOrNull(str) + HxOverrides.stringOrNull((("," + HxOverrides.stringOrNull(",".join([python_Boot.toString1(x1,'') for x1 in Reflect.field(infos,"customParams")]))))))
    		else:
    			str = v
    		python_Lib.println(str)
    
    
    @_hx_classes.registerClass("haxe.ds.StringMap", fields=["h"], interfaces=[haxe_IMap])
    class haxe_ds_StringMap:
    
    	def __init__(self):
    		self.h = None
    		self.h = python_lib_Dict()
    
    	@staticmethod
    	def _hx_empty_init(_hx_o):
    		_hx_o.h = None
    
    
    @_hx_classes.registerClass("python.HaxeIterator", fields=["it","x","has","checked"], methods=["next","hasNext"])
    class python_HaxeIterator:
    
    	def __init__(self,it):
    		self.it = None
    		self.x = None
    		self.has = None
    		self.checked = None
    		self.checked = False
    		self.has = False
    		self.x = None
    		self.it = it
    
    	def next(self):
    		if (not self.checked):
    			self.hasNext()
    		self.checked = False
    		return self.x
    
    	def hasNext(self):
    		if (not self.checked):
    			try:
    				self.x = self.it.__next__()
    				self.has = True
    			except Exception as _hx_e:
    				_hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
    				if python_lib_Builtin.isinstance(_hx_e1, StopIteration):
    					s = _hx_e1
    					self.has = False
    					self.x = None
    				else:
    					raise _hx_e
    			self.checked = True
    		return self.has
    
    	@staticmethod
    	def _hx_empty_init(_hx_o):
    		_hx_o.it = None
    		_hx_o.x = None
    		_hx_o.has = None
    		_hx_o.checked = None
    
    
    @_hx_classes.registerClass("python.Lib", statics=["println"])
    class python_Lib:
    
    	@staticmethod
    	def println(v):
    		str = Std.string(v)
    		python_lib_Sys.stdout.buffer.write((("" + HxOverrides.stringOrNull(str)) + "\n").encode("utf-8", "strict"))
    		python_lib_Sys.stdout.flush()
    
    
    @_hx_classes.registerClass("python.NativeStringTools", statics=["encode"])
    class python_NativeStringTools:
    
    	@staticmethod
    	def encode(s,encoding = "utf-8",errors = "strict"):
    		if (encoding is None):
    			encoding = "utf-8"
    		if (errors is None):
    			errors = "strict"
    		return s.encode(encoding, errors)
    
    
    @_hx_classes.registerClass("_HxException", fields=["val"], superClass=Exception)
    class _HxException(Exception):
    
    	def __init__(self,val):
    		self.val = None
    		message = Std.string(val)
    		super().__init__(message)
    		self.val = val
    
    	@staticmethod
    	def _hx_empty_init(_hx_o):
    		_hx_o.val = None
    
    
    @_hx_classes.registerClass("HxString", statics=["split","charCodeAt","charAt","lastIndexOf","toUpperCase","toLowerCase","indexOf","toString","get_length","fromCharCode","substring","substr"])
    class HxString:
    
    	@staticmethod
    	def split(s,d):
    		if (d == ""):
    			return python_lib_Builtin.list(s)
    		else:
    			return s.split(d)
    
    	@staticmethod
    	def charCodeAt(s,index):
    		if ((((s is None) or ((python_lib_Builtin.len(s) == 0))) or ((index < 0))) or ((index >= python_lib_Builtin.len(s)))):
    			return None
    		else:
    			return python_lib_Builtin.ord(s[index])
    
    	@staticmethod
    	def charAt(s,index):
    		if ((index < 0) or ((index >= python_lib_Builtin.len(s)))):
    			return ""
    		else:
    			return s[index]
    
    	@staticmethod
    	def lastIndexOf(s,str,startIndex = None):
    		if (startIndex is None):
    			return s.rfind(str, 0, python_lib_Builtin.len(s))
    		else:
    			i = s.rfind(str, 0, (startIndex + 1))
    			startLeft = None
    			if (i == -1):
    				startLeft = python_lib_Builtin.max(0,((startIndex + 1) - python_lib_Builtin.len(str)))
    			else:
    				startLeft = (i + 1)
    			check = s.find(str, startLeft, python_lib_Builtin.len(s))
    			if ((check > i) and ((check <= startIndex))):
    				return check
    			else:
    				return i
    
    	@staticmethod
    	def toUpperCase(s):
    		return s.upper()
    
    	@staticmethod
    	def toLowerCase(s):
    		return s.lower()
    
    	@staticmethod
    	def indexOf(s,str,startIndex = None):
    		if (startIndex is None):
    			return s.find(str)
    		else:
    			return s.find(str, startIndex)
    
    	@staticmethod
    	def toString(s):
    		return s
    
    	@staticmethod
    	def get_length(s):
    		return python_lib_Builtin.len(s)
    
    	@staticmethod
    	def fromCharCode(code):
    		return "".join(python_lib_Builtin.map(python_lib_Builtin.chr,[code]))
    
    	@staticmethod
    	def substring(s,startIndex,endIndex = None):
    		if (startIndex < 0):
    			startIndex = 0
    		if (endIndex is None):
    			return s[startIndex:]
    		else:
    			if (endIndex < 0):
    				endIndex = 0
    			if (endIndex < startIndex):
    				return s[endIndex:startIndex]
    			else:
    				return s[startIndex:endIndex]
    
    	@staticmethod
    	def substr(s,startIndex,len = None):
    		if (len is None):
    			return s[startIndex:]
    		else:
    			if (len == 0):
    				return ""
    			return s[startIndex:(startIndex + len)]
    Math.NEGATIVE_INFINITY = python_lib_Builtin.float("-inf")
    Math.POSITIVE_INFINITY = python_lib_Builtin.float("inf")
    Math.NaN = python_lib_Builtin.float("nan")
    Math.PI = python_lib_Math.pi
    python_Boot.keywords = python_lib_Set(["and", "del", "from", "not", "while", "as", "elif", "global", "or", "with", "assert", "else", "if", "pass", "yield", "break", "except", "import", "print", "float", "class", "exec", "in", "raise", "continue", "finally", "is", "return", "def", "for", "lambda", "try", "None", "list", "True", "False"])
    python_Boot.prefixLength = python_lib_Builtin.len("_hx_")
    EnumSample.main()

## Useful Links

- Articles: https://python-commandments.org/
- Python shell: https://bsdnerds.org/learn-python/
